\documentclass[12pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[naustrian]{babel}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{float}
\usepackage{tikz}
\usepackage{bookmark}
\usepackage{epigraph}

%pdfs
\usepackage{pdfpages}
\usepackage{tikz}

%page borders
\usepackage{geometry}
\geometry{left=2.5cm,right=2.5cm,top=3cm,bottom=2.5cm}

\usepackage{minted}
\setminted {
	%style=igor, %borland, autumn, vs
	encoding=utf-8,
	autogobble,
	tabsize=4,
	linenos,
	breaklines,
	%escapeinside=||
	%bgcolor=bg
	frame=single
}

\newenvironment{code}{\captionsetup{type=listing}}{}
\setlength\epigraphwidth{0.8\textwidth}

%title/footer/header values
\usepackage{titling}
\title{SWE Zusammenfassung}
\author{Elias Leonhardsberger}
\date{\today{}, Hagenberg}

%footer/header
%\usepackage[automark]{scrpage2}
%\pagestyle{headings}
%\clearscrheadfoot
%\ihead{\thetitle}
%\chead{\theauthor}
%\ohead{\today}
%\cfoot{Seite \pagemark}

\begin{document}
\maketitle
\tableofcontents

\pagebreak

\section{C++}
\subsection{Standard Library}
Der Namensraum \emph{std} ist für die Standardbibliothek von C++ und C reserviert.
Alle C Header-Dateien sind in C++ verfügbar, ihr Name ist immer mit einem \emph{c}
vorangestellt, z.B. \emph{cstdio} für \emph{stdio.h} in C.

\subsubsection{Strings}
Im gegensatz zu C, wo Strings als char-Arrays implementiert sind, gibt es in C++
die Klasse \emph{std::string}, die es ermöglicht mit Templates Strings aus \emph{char},
\emph{wchar\_t} oder einem beliebigen eigenen Typ zu erstellen. Die ersten beiden
Varianten sind bereits vordefiniert.

\begin{minted}{cpp}
typedef basic_string< char >   string;
typedef basic_string<wchar_t> wstring;
\end{minted}

\subsubsection{Ein-/Ausgabe}
In C und C++ gibt es keine in die Sprache eingebauten Ein-/Ausgabefunktionen. In C werden
die Funktionen aus \emph{stdio.h} verwendet, in C++ die Klassen aus \emph{iostream}.

Der Unterscheid ist, dass C++ mit Streams arbeitet, diese sind
\begin{itemize}
	\item typsicher
	\item implementierbar für eigene Klassen
	\item effizienter da man nicht auf interpretierte Formatzeichenketten angewiesen ist(z.B. \emph{\%d} für int)
	\item auf Zeichenebene Thread-sicher
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.49\textwidth]{images/cpp_1.png}
	\includegraphics[width=0.49\textwidth]{images/cpp_2.png}
	\caption{Klassenhierarchie der Ein-/Ausgabeklassen in C++}
\end{figure}

Diese Streams sind in mehreren Header-Dateien aufgeteilt:
\begin{itemize}
	\item \textbf{iosfwd} für Vorwärtsdeklarationen(Sehr klein)
	\item \textbf{streambuf} für die Pufferung von Ein-/Ausgabe
	\item \textbf{istream} für die Eingabe
	\item \textbf{ostream} für die Ausgabe
	\item \textbf{iostream} für die Standard-Ein-/Ausgabe
	\item \textbf{fstream} für Dateiein-/ausgabe
	\item \textbf{sstream} für String-Ein-/Ausgabe
	\item \textbf{strstream} für für Char*-Ein-/Ausgabe
	\item \textbf{iomanip} für Ein-/Ausgabeformatierung
\end{itemize}

Flush kann auch mit Stream Aufrufen verkettet werden, z.B. \emph{cout << std::flush;}.
\emph{std::endl} flusht den Stream auch nachdem er einen Zeilenumbruch ausgegeben hat.
Achtung kann Performanceprobleme verursachen, da es den Puffer jedes Mal leert! Wenn mehrere
Zeilenumbrüche ausgegeben werden eher den folgenden Ausschnitt verwenden.

\begin{minted}{cpp}
stream << "\n"
\end{minted}

Es gibt auch diverse Manipulatoren, die das Verhalten von Streams beeinflussen.
\begin{itemize}
	\item \emph{std::dec} für Dezimalzahlen
	\item \emph{std::hex} für Hexadezimalzahlen
	\item \emph{std::oct} für Oktalzahlen
	\item \emph{std::setbase(n)} für die Basis der Zahlendarstellung
	\item \emph{std::setfill(c)} für das Füllzeichen
	\item \emph{std::setprecision(n)} für die Anzahl der Nachkommastellen
	\item \emph{std::setw(n)} für die Breite des Feldes
\end{itemize}
\pagebreak

\subsection{STL}
\epigraph{!!Diese Schablone hat keine Laufzeitprüfungen!!}{\textit{Doblers Foliensatz}}

Generische Programmierung statt OOP um den Code wiederverwendbar und effizient zu machen.

Die STL ist in mehrere Teile aufgeteilt:
\begin{itemize}
	\item \textbf{Behälter} für die Speicherung von Daten
	\item \textbf{Iteratoren} für den Zugriff auf die Daten
	\item \textbf{Algorithmen} für die Verarbeitung von Daten
	\item \textbf{Funktionsobjekte} für die Kapselung von Funktionen für andere Komponenten
	\item \textbf{Adapter} für die Anpassung von Behälter und Iteratoren
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{images/stl_1.png}
	\caption{Verhältnisse der STL Komponenten}
\end{figure}

\subsubsection{Iteratoren}
Iteratoren sind eine Verallgemeinerung von Zeigern, die eine abstrakte Schnittstelle zwischen
Behältern und Algorithmen darstellen.

In der STL sind Iteratoren mithilfe von Ducktyping umgesetzt, das heißt, wenn die Schnittstelle erfüllt ist,
also die Methoden richtig implementiert sind, dann kann der Iterator verwendet werden.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{images/stl_2.png}
	\caption{Iteratoren in der STL}
\end{figure}

Allgemein müssen Iteratoren die Vergleichsoperatoren \emph{==} und \emph{!=} implementieren, um zu überprüfen,
ob zwei Iteratoren auf das gleiche Element zeigen, und die Dereferenzierungsoperatoren \emph{*},
um auf das Element zuzugreifen.

Der \textbf{Vorwärtsiterator} implementiert zusätzlich den Inkrementoperator \emph{++}, um zum nächsten Element zu gelangen.

Der \textbf{bidirektionale Iterator} implementiert zusätzlich den Dekrementoperator \emph{--},
um zum vorherigen Element zu gelangen.

Der \textbf{Random-Access-Iterator} implementiert zusätzlich die Operatoren \emph{+}, \emph{-}, \emph{+=} und \emph{-=}, um auf ein
beliebiges Element im Behälter zuzugreifen, und die Vergleichsoperatoren \emph{<}, \emph{>}, \emph{<=} und \emph{>=},
um die Position der Iteratoren zu vergleichen. Dabei wird auch ein Differenztyp benötigt(z.B. \emph{ptrdiff\_t}).

Der \textbf{Input-Iterator} ist ein Vorwärtsiterator, der nur gelesen werden kann.

Der \textbf{Output-Iterator} ist ein Vorwärtsiterator, auf den nur geschrieben werden kann.
\linebreak

Streams und damit auch Dateien können mit dem \emph{istream\_iterator} und
\emph{ostream\_iterator} als Iteratoren verwendet werden.

Es gibt auch Adapter für Iteratoren, wie
\begin{itemize}
	\item \textbf{reverse\_iterator} für die Umkehrung der Iteration(v.rbegin() und v.rend())
	\item \textbf{back\_insert\_iterator} für das Einfügen von Elementen am Ende eines Behälters
	\item \textbf{front\_insert\_iterator} für das Einfügen von Elementen am Anfang eines Behälters
	\item \textbf{insert\_iterator} für das Einfügen von Elementen an einer bestimmten Position in einem Behälter
\end{itemize}

Die Einfügeiteratoren sind da um die Einfügeoperationen in Algorithmen zu abstrahieren.
\linebreak
Iteratoreigenschaften werden verwendet um verschiedene Implementierungen für verschiedene Iteratoren zu ermöglichen.
Die Eigenschaften sind. Außerdem wird der Wertetyp und er Distanztyp damit gespeichert.

\subsubsection{Behälter}
Behälter sind Klassen, die Daten speichern und verwalten. Es gibt verschiedene Arten von Behältern, die sich in ihrer
Implementierung und ihrem Verhalten unterscheiden. Die wichtigsten Behältertypen sind:

\begin{table}[H]
	\centering
	\begin{tabular}{ p{2.5cm} | p{7cm} | p{5cm} }
		Behältertyp            & Beschreibung
		                       & Verwendung                                                                        \\
		\hline
		\textbf{vector}        & Dynamisches Array, das hinten offen ist und schnellen direkten Zugriff ermöglicht
		                       & Standard für sequentielle Daten                                                   \\
		\hline
		\textbf{list}          & Doppelt verkettete Liste, die schnelle Einfüge-
		und Löschoperationen ermöglicht, aber keine schnelle Zugriffsfunktion
		                       & Wenn häufige Einfüg-/Löschungenoperationen erforderlich sind
		\\
		\hline
		\textbf{deque}         & beidseitig offenes dynamisches Array, das schnellen Zugriff
		auf beide Enden ermöglicht
		                       & Wenn häufige Einfüg-/Löschungenoperationen an beiden Enden erforderlich sind,
		aber direkter Zugriff auch wichtig ist                                                                     \\
		\hline
		\textbf{array}         & Schnittstelle für statisches Array
		                       & Wenn die Größe des Arrays zur Compilezeit bekannt ist und
		STL Algorithmen verwendet werden                                                                           \\
		\hline
		\textbf{forward\_list} & Minimale einfach verkettete Liste
		                       & Wenn Speicherverbrauch wichtig ist und nur Vorwärtsiteration benötigt wird        \\
	\end{tabular}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{ p{2.5cm} | p{7cm} | p{5cm} }
		Behältertyp               & Beschreibung
		                          & Verwendung                                                                \\
		\hline
		\textbf{stack}            & LIFO-Adapter für einen Behälter. Der genaue Behälter ist
		nicht spezifiziert, aber meist ein \emph{deque} oder \emph{vector}
		                          & Wenn nur die zuletzt hinzugefügten Elemente benötigt werden.              \\
		\hline
		\textbf{queue}            & FIFO-Adapter für einen Behälter. Der genaue Behälter ist
		nicht spezifiziert, aber meist ein \emph{deque} oder \emph{list}
		                          & Wenn nur die zuerst hinzugefügten Elemente benötigt werden.               \\
		\hline
		\textbf{priority\_ queue} & Adapter für einen Behälter, der die Elemente nach Priorität
		sortiert. Der genaue Behälter ist nicht spezifiziert, aber meist ein \emph{vector} oder
		\emph{deque}              & Wenn die Elemente nach Priorität sortiert werden müssen.                  \\
		\hline
		\textbf{set}              & Assoziativer Behälter, in dem die Elemente der Zugriffschlüssel
		sind.(Zugriff O(log n))
		                          & Wenn die Elemente als Zugriffschlüssel dienen.                            \\
		\hline
		\textbf{multiset}         & Set in dem Duplikate erlaubt sind
		                          & Wenn die Elemente als Zugriffschlüssel dienen aber Duplikate erlaubt sind \\
		\hline
		\textbf{map}              & Assoziativer Behälter, der zu jedem Schlüssel ein Element zuordnet.
		                          & Wenn auf die Elemente nach einem Schlüssel zugegriffen wird.              \\
		\hline
		\textbf{multimap}         & Map in der Schlüsselduplikate erlaubt sind
		                          & Wenn auf die Elemente nach einem Schlüssel zugegriffen wird,
		aber Duplikate erlaubt sind.                                                                          \\
	\end{tabular}
\end{table}

Assoziative Behälter sind entweder mit einem Rot-Schwarz-Baum oder einem Hash-Table implementiert.

\subsubsection{Funktionsobjekte}

Funktionsobjekte sind Objekte einer Klasse mit öffentlichem operator(). Sie können also wie Funktionspointer aufgerufen werden.
Da es sich aber um Objekte handelt, können sie auch Zustände speichern und so z.B. Zähler implementieren.

In den Folien wird auf 4 besondere Typen eingegangen:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.49\textwidth]{images/stl_3.png}
	\includegraphics[width=0.49\textwidth]{images/stl_4.png}
	\caption{Funktionsobjekte in der STL}
\end{figure}

\subsubsection{Algorithmen}

Die Algorithmen in der STL sind durch Iteratoren unabhängig von den Behältern implementiert.
Parametrisiert werden sie mit Iteratortyp, Wertetyp oder Funktionsobjekten(z.B. Prädikat mit return Typ bool).
Davon können beliebig viele verwendet werden.

\begin{table}[H]
	\centering
	\begin{tabular}{ p{4cm} | p{11cm} }
		Algorithmus           & Beschreibung                                                                                                               \\
		\hline
		ohne Änderungen       &                                                                                                                            \\
		\hline
		\textbf{for\_each}    & Führt eine Funktion auf jedes Element eines Behälters aus                                                                  \\
		\textbf{find}         & Sucht ein Element in einem Behälter(mit ==)                                                                                \\
		\textbf{find\_if}     & Sucht ein Element in einem Behälter, das ein Prädikat erfüllt                                                              \\
		\textbf{count}        & Zählt die Anzahl der Vorkommen eines Elements in einem Behälter                                                            \\
		\textbf{count\_if}    & Zählt die Anzahl der Vorkommen eines Elements in einem Behälter, das ein Prädikat erfüllt                                  \\
		\textbf{equal}        & Vergleicht zwei Behälter auf Gleichheit(mit ==, Reihenfolge ist relevant)                                                  \\
		\textbf{mismatch}     & Vergleicht zwei Behälter auf Ungleichheit                                                                                  \\
		\hline
		mit Änderungen        &                                                                                                                            \\
		\hline
		\textbf{copy}         & Kopiert die Elemente eines Behälters in einen anderen Behälter                                                             \\
		\textbf{copy\_if}     & Kopiert die Elemente eines Behälters in einen anderen Behälter, die ein Prädikat erfüllen                                  \\
		\textbf{remove}       & Entfernt Elemente aus einem Behälter(mit ==)                                                                               \\
		\textbf{remove\_if}   & Entfernt Elemente aus einem Behälter, die ein Prädikat erfüllen                                                            \\
		\textbf{unique}       & Entfernt \textbf{aufeinanderfolgende} Duplikate aus einem Behälter                                                         \\
		\textbf{reverse}      & Kehrt die Reihenfolge der Elemente in einem Behälter um                                                                    \\
		\textbf{sort}         & Sortiert die Elemente eines Behälters in aufsteigender Reihenfolge                                                         \\
		\textbf{stable\_sort} & Sortiert die Elemente eines Behälters in aufsteigender Reihenfolge, aber behält die Reihenfolge von gleichen Elementen bei
	\end{tabular}
\end{table}
\pagebreak

\section{Java}
\subsection{Standard Library}
\subsection{JCF}
\section{Softwaremuster}
\subsection{OOP}
\subsection{Gang of 4}
\subsection{MVC}
\subsection{Iterator}
\subsection{Composite}

\pagebreak
\section{Syntaxvergleich}
Um den Syntax von C++ und Java zu vergleichen, hab ich ein kleines Beispielprogramm geschrieben mit:
\begin{itemize}
	\item einem Interface
	\item einer Basisklasse, die das Interface implementiert
	\item einer abgeleiteten Klasse, die von der Basisklasse erbt
	\item einer Iteratorimplementierung in der abgeleiteten Klasse
	\item einer Main-Methode, die ein Objekt der abgeleiteten Klasse verwendet
\end{itemize}

\subsection{C++}
\subsubsection{Interface}
\inputminted{cpp}{cpp/interface.h}
\subsubsection{Basisklasse}
\inputminted{cpp}{cpp/baseclass.h}
\subsubsection{Abgeleitete Klasse}
\inputminted{cpp}{cpp/derivedclass.h}
\subsubsection{Main}
\inputminted{cpp}{cpp/main.cpp}
\pagebreak

\subsection{Java}
\subsubsection{Interface}
\inputminted{java}{java/src/main/java/javademo/Interface.java}
\subsubsection{Basisklasse}
\inputminted{java}{java/src/main/java/javademo/Baseclass.java}
\subsubsection{Abgeleitete Klasse}
\inputminted{java}{java/src/main/java/javademo/Derivedclass.java}
\subsubsection{Main}
\inputminted{java}{java/src/main/java/javademo/Demo.java}
\pagebreak

% C# kommt nicht zur Klausur
% \subsection{C\#}
% \subsubsection{Interface}
% \inputminted{csharp}{csharp/IInterface.cs}
% \subsubsection{Basisklasse}
% \inputminted{csharp}{csharp/Baseclass.cs}
% \subsubsection{Abgeleitete Klasse}
% \inputminted{csharp}{csharp/Derivedclass.cs}
% \subsubsection{Main}
% \inputminted{csharp}{csharp/Program.cs}
% \pagebreak

\end{document}